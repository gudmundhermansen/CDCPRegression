# Title: Monitoring Bridge
#
# Summary:
#
# TODO:
#
cdcp.regression.bridge.function <- function(data, index_val) {

  n         <- data$n
  y         <- data$y
  X         <- data$X
  Z         <- data$Z
  index     <- data$index
  Dummy     <- data$D # Make Global Dummy instead?

  # From the old code, not optimised for this problem.
  bb_estimation <- foreach::foreach(i = seq_along(index_val), .combine = rbind) %dopar% {

    index_i    <- index <= index_val[i]
    n_i        <- sum(index_i)

    y_left     <- y[index_i]
    X_left     <- X[index_i, ]
    Z_left     <- NULL; if (!is.null(Z)) Z_left <- Z[index_i, ]
    Dummy_left <- NULL; if (!is.null(Dummy)) Dummy_left <- Dummy[index_i, ]

    tmp_lm_i      <- lm(y_left ~ -1 + cbind(X_left, Z_left, Dummy_left))
    tmp_res_i     <- tmp_lm_i$residuals

    tmp_sigma2_i  <- mean(tmp_res_i^2)
    tmp_profile_i <- -(n_i/2)*(log(2*pi) + log(tmp_sigma2_i) + 1)

    c(index_val[i], n_i, tmp_profile_i)
  }

  bb_estimation <- bb_estimation[rowSums(bb_estimation) < Inf, ]

  year_val <- bb_estimation[, 1]
  year_n   <- bb_estimation[, 2]
  year_ll  <- bb_estimation[, 3]

  x0        <- year_val[1]
  x1        <- year_val[length(year_val)]
  y0        <- year_ll[1]
  y1        <- year_ll[length(year_val)]
  b         <- (y1 - y0)/(x1 - x0)
  a         <- -b*x1 + y1

  K         <- year_n[length(year_val)]
  k         <- year_n
  kappa_hat <- sqrt(mean((diff(year_ll)/diff(year_n) - data.table::last(year_ll/year_n))^2))
  # kappa_hat <- 1/sqrt(2)

  BBL       <- K^(-1/2)*(  year_ll[1:length(year_val)] - (a + b*year_val))/kappa_hat
  # BBL       <- K^(-1/2)*(year_ll[1:length(year_val)] - (k/K)*year_ll[length(year_val)])/kappa_hat

  return(list(index_val = index_val, bbridge = BBL))
}

cdcp.regression.bridge.check <- function(bridge) {
  
  if (!all(c("index_val", "bbridge") %in% attributes(bridge)$names)) {
    stop("ERROR: model is not a proper bridge model object. \n")
  }
  
  if (!is.numeric(bridge$index_val)) {
    stop("ERROR: The index_val has to be numerical.\n")
  }
  
  if (!is.numeric(bridge$bbridge)) {
    stop("ERROR: The bbridge has to be numerical.\n")
  }
  
  if (length(bridge$bbridge) != length(bridge$index_val)) {
    stop("ERROR: The bbridge and index_val are of different length. \n")
  }
  
}

#' Monitoring Bridge
#'
#' This function compute the monitoring bridge for a set of indexes (index_val). It generate the necessary values to make a monitoring bridge plot for the cdcp.regression.bridge.plot(...) function. 
#'
#' @param data A CDCP Regression data object generated by the cdcp.regression.data(...) function.  
#' @param index_val A sequence a sequence of indexes representing potential locations of chage points.  
#' @return a list consisting of two vectors: 
#' \describe{
#'   \item{index_val}{The same sequence of indexes as in the argument.}
#'   \item{bbridge_val}{The computed monitoring bridge values.}
#' }
#' \itemize{
#'  \item{"parameter 1"}{Stuff}
#'  \item{}{Stuff}
#' }
#' @references Cunen, C., Hermansen, G., & Hjort, N. L. (2018). Confidence distributions for change-points and regime shifts. Journal of Statistical Planning and Inference, 195, 14-34.
#' @examples
#' data <- cdcp.regression.data.sim()
#' model <- cdcp.regression.bridge(data$data, data$index_val)
#' @export
#' @import foreach
#' @import doMC
cdcp.regression.bridge <- function(data, index_val, cores = 4) {
  
  # TODO: It should be possible to have index_val = NULL and then get the maximum range
  
  # Check data in data object
  cdcp.regression.data.check.data(data)
  
  # Check of parameters: 
  if (!is.numeric(index_val)) {
    stop("ERROR: The index_val has to be numerical.\n")
  }  
  
  if (!all(index_val %in% data$index)) {
    stop("ERROR: Some values of index_val are not among index in the data object.\n")
  }  
  
  doMC::registerDoMC(cores)

  return(cdcp.regression.bridge.function(data = data, index_val = index_val))
}

#' Plot of Monitoring Bridge  
#'
#' Plot the so-called monitoring bridge using the output of the `cdcp.regression.bridge(...)` function. 
#'
#' @param bridge The output from running the `cdcp.regression.bridge(...)` function.
#' @references Cunen, C., Hermansen, G., & Hjort, N. L. (2018). Confidence distributions for change-points and regime shifts. Journal of Statistical Planning and Inference, 195, 14-34.
#' @examples
#' 
#' Example 1:
#' data <- cdcp.regression.data.sim()
#' bridge <- cdcp.regression.bridge(data$data, data$index_val)
#' cdcp.regression.bridge.plot(bridge)
#' 
#' Example 2: A simple example 
#' n <- 100
#' x <- 1:n
#' X <- cbind(1, x)
#' mu <- 3*(x <= 50) + x
#' y <- mu + rnorm(n)
#' 
#' # plot of simulated data
#' plot(x, y)
#' lines(x, mu)
#' 
#' # create list of data for CDCP Regression analysis 
#' index <- x
#' group <- x*0 + 1
#' data <- cdcp.regression.data(y = y, X = X, index = index, group = group)
#' 
#' # run monitoring bridge model and plot results
#' bridge <- cdcp.regression.bridge(data, index_val = 10:90)
#' cdcp.regression.bridge.plot(bridge)
#' @export
cdcp.regression.bridge.plot <- function(bridge) {

  cdcp.regression.bridge.check(bridge)
  
  index_val <- bridge$index_val
  bbridge <- bridge$bbridge

  ylim <- c(min(c(-1.358, bbridge)), max(c(1.358, bbridge)))
  plot(index_val, bbridge, type = 'l', lwd = 1.3, ylim = ylim, xlab = "", ylab = "")
  title(ylab = "Monitoring Bridge", line = 2.5)
  abline(h = 1.358*c(-1, 0, 1), col = 'grey70', lty = c(2, 3, 2), lwd = 1.6)
}




